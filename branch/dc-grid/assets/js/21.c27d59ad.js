(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{538:function(e,t,a){"use strict";a.r(t);var i=a(18),r=Object(i.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"communication"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#communication"}},[e._v("#")]),e._v(" Communication")]),e._v(" "),a("p",[e._v("In a simple PV setup, one device might be sufficient to handle the panels, battery charging and load switching. But with a growing system, more and more device are added, with specific tasks for which they are optimized. A "),a("RouterLink",{attrs:{to:"/system/bms.html"}},[e._v("BMS")]),e._v(" for each battery, a couple of "),a("RouterLink",{attrs:{to:"/system/charge_controller.html"}},[e._v("charge controllers")]),e._v(" and maybe even a database and a frontend to store and display settings and data series.")],1),e._v(" "),a("p",[e._v("All these devices need to "),a("strong",[e._v("communicate")]),e._v(" with each other, with different requirements concerning speed, reliability or efficiency. For these networks of devices (IoT = Internet of Things), several technologies have been developed. Similar to the "),a("a",{attrs:{href:"https://en.wikipedia.org/wiki/OSI_model",target:"_blank",rel:"noopener noreferrer"}},[e._v("OSI model"),a("OutboundLink")],1),e._v(", different layers have been identified, but in this document we speak of the "),a("strong",[e._v("application layer")]),e._v(" and the "),a("strong",[e._v("lower layers")]),e._v(" which roughly corresponds to the data model and the data transportation.")]),e._v(" "),a("p",[e._v("This chapter will give an overview of existing and popular protocols.")]),e._v(" "),a("h2",{attrs:{id:"requirements"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#requirements"}},[e._v("#")]),e._v(" Requirements")]),e._v(" "),a("p",[e._v("To be able to compare protocols, some specifications should be postulated. These are arbitrary based on the needs identified for Libre Solar devices and could be changed e.g. for automotive needs.")]),e._v(" "),a("h3",{attrs:{id:"lower-layers"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lower-layers"}},[e._v("#")]),e._v(" Lower layers")]),e._v(" "),a("ol",[a("li",[a("p",[a("strong",[e._v("Reliability:")]),e._v(" Packet loss, ordering of packets for multiframe messages etc. should be handled. The connection should be somewhat resistant to noise since devices like the charge-controller contain switching circuits and handle high currents.")])]),e._v(" "),a("li",[a("p",[a("strong",[e._v("Masterless:")]),e._v(" Bidirectional communication and broadcasting should be possible. Protocols like "),a("a",{attrs:{href:"https://de.wikipedia.org/wiki/I%C2%B2C",target:"_blank",rel:"noopener noreferrer"}},[e._v("IÂ²C"),a("OutboundLink")],1),e._v(" or "),a("a",{attrs:{href:"https://de.wikipedia.org/wiki/Serial_Peripheral_Interface",target:"_blank",rel:"noopener noreferrer"}},[e._v("SPI"),a("OutboundLink")],1),e._v(", which are often used with Arduinos, are not suitable. They also have quite low maximum cable length.")])]),e._v(" "),a("li",[a("p",[a("strong",[e._v("Speed:")]),e._v(" To transmit larger amounts of logging data or even firmware updates, the speed should be considered.")])])]),e._v(" "),a("h3",{attrs:{id:"application-layer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#application-layer"}},[e._v("#")]),e._v(" Application layer")]),e._v(" "),a("ol",[a("li",[a("p",[a("strong",[e._v("Schema-less:")]),e._v(" The data structure should be discoverable and self-explaining. This means the client does not need to know the schema of the devices data, e.g. variable types and units should be delivered with the data, executable functions should can be identified etc.")])]),e._v(" "),a("li",[a("p",[a("strong",[e._v("Flexible:")]),e._v(" The protocol should be independent of those protocols used in lower layers. It is ok to assume data integrity completeness and correct order, which should be checked by lower layer protocols.")])]),e._v(" "),a("li",[a("p",[a("strong",[e._v("Stateless:")]),e._v(" Each request should be atomic regarding the information needed to process it. No session handling is done.")])]),e._v(" "),a("li",[a("p",[a("strong",[e._v("Compact:")]),e._v(" Overhead like headers or data representation should be compact. Especially with IoT, lower layer protocols and connections are not very powerful, so low data rates should be expected and addressed.")])])]),e._v(" "),a("h2",{attrs:{id:"lower-layers-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lower-layers-2"}},[e._v("#")]),e._v(" Lower layers")]),e._v(" "),a("h3",{attrs:{id:"can"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#can"}},[e._v("#")]),e._v(" CAN")]),e._v(" "),a("p",[e._v('The Controller Area Network (CAN) was developed by the automotive industry to connect the different systems within a vehicle. It is a multimaster, electrical noise tolerant two wire bus system. The logical level on the bus is achieved with a differential approach, allowing for cable distances of more than 100m. Each end of the bus has to be terminated using a termination resistor [1]. Differential logic means that the voltage difference between the two wires indicate whether a "high" (logic 1) or "low" (logic 0) is written. In CAN, these states are called "recessive" and "dominant" respectively. The voltage difference depends on the used standard, in 5V systems it is usually around 2V.')]),e._v(" "),a("p",[e._v("The CAN Standard itself defines only the physical and data-link layer (layer 1 and 2 in OSI) with a maximum size of 8 bytes. In order to send larger messages, a protocol like "),a("a",{attrs:{href:"https://en.wikipedia.org/wiki/ISO_15765-2",target:"_blank",rel:"noopener noreferrer"}},[e._v("ISO 15765-2 - ISO-TP"),a("OutboundLink")],1),e._v(" can be used.")]),e._v(" "),a("p",[e._v("CAN offers a transmission speed up to 5 Mbit/s, which greatly decreases the possible wire length. With a speed of 500 kbit/s, wires up to 100m can be used.")]),e._v(" "),a("h4",{attrs:{id:"message-layout"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#message-layout"}},[e._v("#")]),e._v(" Message Layout")]),e._v(" "),a("p",[e._v("There are two frame formats defined, the base frame format with 11 identifier bits and the extended frame format, using 29 bits for message identification [2].")]),e._v(" "),a("p",[e._v("The (simplified) base frame format:")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",[e._v("#Bits")]),e._v(" "),a("th",{staticStyle:{"text-align":"center"}},[e._v("1")]),e._v(" "),a("th",{staticStyle:{"text-align":"center"}},[e._v("11")]),e._v(" "),a("th",{staticStyle:{"text-align":"center"}},[e._v("7")]),e._v(" "),a("th",{staticStyle:{"text-align":"center"}},[e._v("0 .. 64")]),e._v(" "),a("th",{staticStyle:{"text-align":"center"}},[e._v("16")]),e._v(" "),a("th",{staticStyle:{"text-align":"center"}},[e._v("2")]),e._v(" "),a("th",{staticStyle:{"text-align":"center"}},[e._v("7")])])]),e._v(" "),a("tbody",[a("tr",[a("td"),e._v(" "),a("td",{staticStyle:{"text-align":"center"}},[e._v("SOF")]),e._v(" "),a("td",{staticStyle:{"text-align":"center"}},[e._v("ID")]),e._v(" "),a("td",{staticStyle:{"text-align":"center"}},[e._v("CTL")]),e._v(" "),a("td",{staticStyle:{"text-align":"center"}},[e._v("DATA")]),e._v(" "),a("td",{staticStyle:{"text-align":"center"}},[e._v("CRC")]),e._v(" "),a("td",{staticStyle:{"text-align":"center"}},[e._v("ACK")]),e._v(" "),a("td",{staticStyle:{"text-align":"center"}},[e._v("EOF")])])])]),e._v(" "),a("p",[a("strong",[e._v("SOF:")]),e._v(" Start of frame "),a("br"),e._v(" "),a("strong",[e._v("ID:")]),e._v(" Unique Identifier which also determines the priority "),a("br"),e._v(" "),a("strong",[e._v("CTL:")]),e._v(" Control bits, including the length of data (0..8 bytes) "),a("br"),e._v(" "),a("strong",[e._v("CRC:")]),e._v(" Cyclic Redundancy Check, used to detect transmission errors "),a("br"),e._v(" "),a("strong",[e._v("ACK:")]),e._v(" Acknowledgment bits "),a("br"),e._v(" "),a("strong",[e._v("EOF:")]),e._v(" Bit sequence to signal the end of frame")]),e._v(" "),a("p",[e._v("With the extended frame format, 18 additional bits are used for the ID field which can be used to split the ID into message priority and target and source address.")]),e._v(" "),a("h4",{attrs:{id:"arbitration"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#arbitration"}},[e._v("#")]),e._v(" Arbitration")]),e._v(" "),a("p",[e._v("Since CAN is masterless, every node on the bus can start sending at any time. To detect collisions, the transceiver always compares its output to the input. If another device with a higher priority (lower ID) is sending at the same time, a difference between input and output will be detected and the lower priority device will retreat.")]),e._v(" "),a("h3",{attrs:{id:"uart"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#uart"}},[e._v("#")]),e._v(" UART")]),e._v(" "),a("p",[e._v("The Universal Asynchronous Receiver Transmitter is the most common serial communication used in MCUs. It has a receive (RX) and a transmit (TX) line, which are cross-connected between two devices. It allows only two connected devices and does not need any additional wiring, both microcontrollers should share the same ground and the same maximum voltage.")]),e._v(" "),a("p",[e._v("Since there are only two devices and separate wires for sending and receiving, no identification or arbitration is needed. UART does not implement any error checking, so higher layers need to check for data integrity.")]),e._v(" "),a("h3",{attrs:{id:"bluetooth"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bluetooth"}},[e._v("#")]),e._v(" Bluetooth")]),e._v(" "),a("p",[e._v("Bluetooth (BT) is a widely used wireless connection protocol developed for medium-bandwidth, low range applications. For many application layer protocols, the Serial Port Profile (SPP) of the older Bluetooth standard is mostly suited as it simulates a serial interface and is therfore interchangeable with UART or USB. For the modern Bluetooth Low Energy, a custom profile has to be created as the SPP is no longer availabe.")]),e._v(" "),a("h3",{attrs:{id:"usb"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#usb"}},[e._v("#")]),e._v(" USB")]),e._v(" "),a("p",[e._v("The Universal Serial Bus uses differential logic levels with two wires, just like CAN. It is implemented as a primary/secondary topology, meaning a host device initiates and organizes communication to connected peripheral devices. Each devices has its own unique address and broadcasting is not possible. Since USB was developed for desktop use with high-bandwidth and low cable range, it is not widely used for MCU communication. It is however often used to connect a MCU with a PC via an USB-to-UART converter for programming and debugging. In this case, the same rules as for "),a("a",{attrs:{href:"#UART"}},[e._v("UART")]),e._v(" applies concerning error checking.")]),e._v(" "),a("h2",{attrs:{id:"application-layer-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#application-layer-2"}},[e._v("#")]),e._v(" Application layer")]),e._v(" "),a("h3",{attrs:{id:"thingset"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#thingset"}},[e._v("#")]),e._v(" ThingSet")]),e._v(" "),a("p",[e._v("The "),a("a",{attrs:{href:"https://libre.solar/thingset/",target:"_blank",rel:"noopener noreferrer"}},[e._v("ThingSet"),a("OutboundLink")],1),e._v(" protocol ("),a("strong",[e._v("set")]),e._v("tings of "),a("strong",[e._v("thing")]),e._v("s) was developed by Libre Solar to provide a flexible, compact, stateless and schema-less method for communication. It is entirely Open Source and aims to mitigate the problems arising from proprietary alternatives as well as to deliver improved functionality.")]),e._v(" "),a("p",[e._v("With a human-readable text mode and the more compact binary mode it can easily be adapted to the capabilities of the underlaying lower layers. The used response status and request methods are mostly compatible with other standards like "),a("a",{attrs:{href:"#CoAP"}},[e._v("CoAP")]),e._v(" or "),a("a",{attrs:{href:"#HTTP"}},[e._v("HTTP")]),e._v(" and tries to follow the "),a("a",{attrs:{href:"https://en.wikipedia.org/wiki/Representational_state_transfer",target:"_blank",rel:"noopener noreferrer"}},[e._v("REST"),a("OutboundLink")],1),e._v(" principles.")]),e._v(" "),a("p",[e._v("For a full explanation, visit the "),a("a",{attrs:{href:"https://libre.solar/thingset/2a_general.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("documentation pages"),a("OutboundLink")],1),e._v(".")]),e._v(" "),a("h3",{attrs:{id:"mqtt"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mqtt"}},[e._v("#")]),e._v(" MQTT")]),e._v(" "),a("p",[e._v("The Message Queuing Telemetry Transport (MQTT) protocol is mainly used for device-to-device communication in a publish/subscribe manner. It was designed for both a small code and bandwidth footprint required in restricted environments like IoT [3].")]),e._v(" "),a("p",[e._v("A Broker is used to manage all communication between the devices. It receives any published data and sends it to all subscribers. The data is organized in topics and a client can both subscribe and publish. Multiple devices can publish and subscribe to the same topic.")]),e._v(" "),a("p",[e._v("More detailed explanations and guides can be found "),a("a",{attrs:{href:"https://www.hivemq.com/mqtt-essentials/",target:"_blank",rel:"noopener noreferrer"}},[e._v("here"),a("OutboundLink")],1)]),e._v(" "),a("h3",{attrs:{id:"coap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#coap"}},[e._v("#")]),e._v(" CoAP")]),e._v(" "),a("p",[e._v("The Constrained Application Protocol is designed for restricted environments as an alternative or connection layer to "),a("a",{attrs:{href:"#HTTP"}},[e._v("HTTP")]),e._v(" [4]. It features a subset of HTTP request methods and return values and follows the same client/server pattern without publish/subscribe features. In contrast to MQTT, COAP relies on UDP connections and the entire frame cannot be larger than the UDP datagram (~64 KBytes). Therefor, sending or receiving larger amounts of data has to be handled by the application itself.")]),e._v(" "),a("h3",{attrs:{id:"http"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http"}},[e._v("#")]),e._v(" HTTP")]),e._v(" "),a("p",[e._v('The Hypertext Transfer Protocol and the secured version HTTPS is the main standard in modern web applications. It features many request types, a sophisticated range of return values along with the possibility to define custom headers. HTTP follows the request/response scheme, so there is always a server and a client involved. The payload is sent as the "body", which can be of any type and the size is only limited by the client/server implementation.')]),e._v(" "),a("p",[e._v("Due to its complex functionalities and therefore increased overhead and code size, it is not very well suited for IoT applications.")]),e._v(" "),a("p",[e._v("HTTP does not implement error checking and relies on lower layer protocols to care for data integrity. Due to its complexity, overhead can be quite significant e.g. just the header section can be up to 1 KByte.")]),e._v(" "),a("h3",{attrs:{id:"modbus"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#modbus"}},[e._v("#")]),e._v(" Modbus")]),e._v(" "),a("p",[e._v("Modbus RTU and Modbus TCP are quite old, quasi-standard protocols to read and write registers of a device. Modbus requires knowledge of the accessible register addresses and the data format. A method to discover available settings and measurement values is not possible, so it does not fulfill the requirement to be self-describing.")]),e._v(" "),a("h3",{attrs:{id:"canopen"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#canopen"}},[e._v("#")]),e._v(" CANopen")]),e._v(" "),a("p",[e._v('CANopen is developed by CAN in Automation (CiA). This high level protocol uses CAN as physical layer and adds profile specifications, standardized communication protocol and advanced error handling to the core functionality of CAN. Despite the word "open" in the name, only the basic device profile specifications are open accessible. A paid CiA membership is necessary to access all specifications. Unfortunately, the EnergyBus profiles (CiA 454) for a CAN based energy management system are not provided with free access.')]),e._v(" "),a("p",[e._v("CiA DS301 specifies the basic communication functionalities of the CANopen application layer.")]),e._v(" "),a("p",[e._v("Every device (called CANopen node) must have an object dictionary (OD). This is a large table stored in the node which contains all kinds of data, including device parameters, measurement or control data. In addition to that, it stores also data necessary for communication e.g. which datatypes are used or how a message can be transported (broadcast, handshake, ..).")]),e._v(" "),a("p",[e._v("There are two different types of telegrams:")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("Service Data Objects (SDOs): These are only used to access the OD. When a device receives an SDO it changes the values of parameters or other OD table entries. The communication is based on a Client/Server relationship. A client initiates an SDO communication, the server then changes its OD according to the client's instruction and sends a response. The client is typically a master device or an operator who supervises and configures the entire network.")])]),e._v(" "),a("li",[a("p",[e._v('Process Data Objects (PDOs): The majority of messages in the bus contain process information like measurement data, control data, status data, etc. The data is read from the OD and transmitted as a PDO, which is basically a pure CAN telegram without protocol overhead. The CAN-identifier of a PDO telegram does not only contain the node-ID of a device (like this is the case in "pure CAN") but also what kind of content is delivered by the telegram.')])])]),e._v(" "),a("p",[e._v("The PDO telegrams are not predefined, but they are configured separately for each network. For each device, four Receive-PDOs (RPDOs) and four Transmit-PDOs (TPDOs) can be defined. For example, the actual current of the battery could be sent as a TPDO by the battery management system and an received as RPDO in a charge controller.")]),e._v(" "),a("p",[e._v("The connection channels between different devices for PDO exchange are defined using a PDO mapping procedure. This has the advantage that the process data exchange between different devices can be very flexible. However, it makes an initial network setup necessary. If a device is added to the network, it has to be shut down, some PDO mappings have to be defined and afterwards the network is put into operation mode again. This contradicts to the requirement of a plug-and-play capable energy system.")]),e._v(" "),a("p",[e._v("An intelligent master device implementing the network management (NMT) features could be used instead of manual configuration. But also a master device is not beneficial for a distributed, fail-safe energy system.")]),e._v(" "),a("p",[e._v("Summary of issues:")]),e._v(" "),a("ul",[a("li",[e._v("Pre-defined frame layout defined in not completely open specification")]),e._v(" "),a("li",[e._v("Complicated network setup (normally done using proprietary tools)")]),e._v(" "),a("li",[e._v("Not intended for master-less operation")]),e._v(" "),a("li",[e._v("Only 4 RPDOs and TPDOs possible per node ID for control functions")])]),e._v(" "),a("h2",[e._v("References")]),e._v(" "),a("p",[e._v("[1] Wikipedia contributors. (2021, June 20). CAN bus. In Wikipedia, The Free Encyclopedia. Retrieved 11:10, June 23, 2021, "),a("a",{attrs:{href:"https://en.wikipedia.org/wiki/CAN_bus",target:"_blank",rel:"noopener noreferrer"}},[e._v("Link"),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("[2] CAN Bus Explained - A simple Intro (2021). Retrieved 11:43, June 23, 2021 "),a("a",{attrs:{href:"https://www.csselectronics.com/screen/page/simple-intro-to-can-bus/language/en",target:"_blank",rel:"noopener noreferrer"}},[e._v("Link"),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("[3] MQQT Essentials - Introducing MQTT. Retrieved 15:27, June 23, 2021 "),a("a",{attrs:{href:"https://www.hivemq.com/blog/mqtt-essentials-part-1-introducing-mqtt/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Link"),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("[4] RFC 7252. Constrained Application Protocol (CoAP). Retrieved 16:37, June 23, 2021 "),a("a",{attrs:{href:"https://datatracker.ietf.org/doc/html/rfc7252",target:"_blank",rel:"noopener noreferrer"}},[e._v("Link"),a("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=r.exports}}]);